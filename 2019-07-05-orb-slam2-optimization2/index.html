<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> 😀 ORB-SLAM2 代码解读（三）：优化 2（详解 &#43; g2o 使用） - 吴言吴语</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="wuxiaolang" /><meta name="description" content="0. 基本使用 0.1 构造 g2o 模型 首先构造 g2o 模型，包括选择线性方程求解器、矩阵求解器和下降算法； 1 2 3 4 5 6 7 8 9 10 11 12 13 // 设置图模型创建优化器. g2o::SparseOptimizer optimizer; //" /><meta name="keywords" content="Hugo, theme, even" />


<meta name="baidu-site-verification" content="fHOS0ah0i1" />
<meta name="google-site-verification" content="4aEA7KB3m7LrWKNH4axTcMxXigooU2CLbEs_pmc_09s" />


<meta name="generator" content="Hugo 0.68.0 with theme even" />


<link rel="canonical" href="https://wym.netlify.com/2019-07-05-orb-slam2-optimization2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.fdd8141c.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content=" 😀 ORB-SLAM2 代码解读（三）：优化 2（详解 &#43; g2o 使用）" />
<meta property="og:description" content="0. 基本使用 0.1 构造 g2o 模型 首先构造 g2o 模型，包括选择线性方程求解器、矩阵求解器和下降算法； 1 2 3 4 5 6 7 8 9 10 11 12 13 // 设置图模型创建优化器. g2o::SparseOptimizer optimizer; //" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wym.netlify.com/2019-07-05-orb-slam2-optimization2/" />
<meta property="article:published_time" content="2019-07-05T00:00:00+08:00" />
<meta property="article:modified_time" content="2019-07-05T00:00:00+08:00" />
<meta itemprop="name" content=" 😀 ORB-SLAM2 代码解读（三）：优化 2（详解 &#43; g2o 使用）">
<meta itemprop="description" content="0. 基本使用 0.1 构造 g2o 模型 首先构造 g2o 模型，包括选择线性方程求解器、矩阵求解器和下降算法； 1 2 3 4 5 6 7 8 9 10 11 12 13 // 设置图模型创建优化器. g2o::SparseOptimizer optimizer; //">
<meta itemprop="datePublished" content="2019-07-05T00:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2019-07-05T00:00:00&#43;08:00" />
<meta itemprop="wordCount" content="12922">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=" 😀 ORB-SLAM2 代码解读（三）：优化 2（详解 &#43; g2o 使用）"/>
<meta name="twitter:description" content="0. 基本使用 0.1 构造 g2o 模型 首先构造 g2o 模型，包括选择线性方程求解器、矩阵求解器和下降算法； 1 2 3 4 5 6 7 8 9 10 11 12 13 // 设置图模型创建优化器. g2o::SparseOptimizer optimizer; //"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">小吴同学的吴言吴语</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">博客</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/slam/">
        <li class="mobile-menu-item">SLAM</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/za/">
        <li class="mobile-menu-item"></li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">小吴同学的吴言吴语</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">博客</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/slam/">SLAM</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/za/"></a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"> 😀 ORB-SLAM2 代码解读（三）：优化 2（详解 &#43; g2o 使用）</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-07-05 </span>
        <div class="post-category">
            <a href="/categories/orb-slam2/"> ORB-SLAM2 </a>
            <a href="/categories/slam/"> SLAM </a>
            <a href="/categories/code/"> code </a>
            </div>
          <span class="more-meta"> 约 12922 字 </span>
          <span class="more-meta"> 预计阅读 26 分钟 </span>
        
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#0-基本使用">0. 基本使用</a>
      <ul>
        <li><a href="#01-构造-g2o-模型">0.1 构造 g2o 模型</a></li>
        <li><a href="#02-g2o-类图">0.2 g2o 类图</a></li>
      </ul>
    </li>
    <li><a href="#1-g2o-的顶点vertex">1. g2o 的顶点（Vertex）</a>
      <ul>
        <li><a href="#11-顶点的格式">1.1 顶点的格式</a></li>
        <li><a href="#12-自定义顶点">1.2 自定义顶点</a></li>
        <li><a href="#13-将顶点添加到图中">1.3 将顶点添加到图中</a></li>
      </ul>
    </li>
    <li><a href="#2-g2o-中的边">2. g2o 中的边</a>
      <ul>
        <li><a href="#21-边的格式">2.1 边的格式</a></li>
        <li><a href="#22-自定义边">2.2 自定义边</a></li>
        <li><a href="#23-将边添加到图中">2.3 将边添加到图中</a></li>
      </ul>
    </li>
    <li><a href="#3-orb-slam2-中的顶点">3. ORB-SLAM2 中的顶点</a>
      <ul>
        <li><a href="#31-相机位姿顶点">3.1 相机位姿顶点</a></li>
        <li><a href="#32-地图点坐标顶点">3.2 地图点坐标顶点</a></li>
        <li><a href="#33-闭环时的-sim3-相机位姿">3.3 闭环时的 sim3 相机位姿</a></li>
      </ul>
    </li>
    <li><a href="#4-orb-slam2-中的边">4. ORB-SLAM2 中的边</a>
      <ul>
        <li><a href="#41-位姿优化时的重投影误差">4.1 位姿优化时的重投影误差</a></li>
        <li><a href="#42-ba-优化时的重投影误差">4.2 BA 优化时的重投影误差</a></li>
        <li><a href="#43-闭环检测时的重投影误差">4.3 闭环检测时的重投影误差</a></li>
        <li><a href="#44-sim3-之间的相对误差">4.4 Sim3 之间的相对误差</a></li>
      </ul>
    </li>
    <li><a href="#5-orb-slam2-中的优化函数">5. ORB-SLAM2 中的优化函数</a>
      <ul>
        <li><a href="#51-位姿优化函数-poseoptimization">5.1 位姿优化函数 PoseOptimization()</a></li>
        <li><a href="#52-局部优化-localbundleadjustment">5.2 局部优化 LocalBundleAdjustment()</a></li>
        <li><a href="#53-全局优化-globalbundleadjustemnt">5.3 全局优化 GlobalBundleAdjustemnt()</a></li>
        <li><a href="#54-闭环处的-sim3-优化-optimizesim3">5.4 闭环处的 Sim3 优化 OptimizeSim3()</a></li>
        <li><a href="#55-闭环后的-sim3-位姿优化-optimizeessentialgraph">5.5 闭环后的 Sim3 位姿优化 OptimizeEssentialGraph()</a></li>
      </ul>
    </li>
    <li><a href="#r-参考资料">R. 参考资料</a></li>
    <li><a href="#todo">TODO</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="0-基本使用">0. 基本使用</h2>
<h3 id="01-构造-g2o-模型">0.1 构造 g2o 模型</h3>
<ul>
<li>首先构造 g2o 模型，包括选择<strong>线性方程求解器、矩阵求解器和下降算法</strong>；
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 设置图模型创建优化器.
</span><span class="c1"></span><span class="n">g2o</span><span class="o">::</span><span class="n">SparseOptimizer</span> <span class="n">optimizer</span><span class="p">;</span>
<span class="c1">// 使用Cholmod中的线性方程求解器得到 linearSolver
</span><span class="c1"></span><span class="n">g2o</span><span class="o">::</span><span class="n">BlockSolver_6_3</span><span class="o">::</span><span class="n">LinearSolverType</span> <span class="o">*</span> <span class="n">linearSolver</span><span class="p">;</span>
<span class="n">linearSolver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">LinearSolverDense</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">BlockSolver_6_3</span><span class="o">::</span><span class="n">PoseMatrixType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// 再用稀疏矩阵块求解器 solver_ptr
</span><span class="c1"></span><span class="n">g2o</span><span class="o">::</span><span class="n">BlockSolver_6_3</span> <span class="o">*</span> <span class="n">solver_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BlockSolver_6_3</span><span class="p">(</span><span class="n">linearSolver</span><span class="p">);</span>
<span class="c1">// 选择梯度下降方法：L-M 算法 求解上面的 solver_ptr 得到 solver.
</span><span class="c1"></span><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmLevenberg</span><span class="o">*</span> <span class="n">solver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmLevenberg</span><span class="p">(</span><span class="n">solver_ptr</span><span class="p">);</span>
<span class="c1">// 设置求解器.
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">setAlgorithm</span><span class="p">(</span><span class="n">solver</span><span class="p">);</span>
<span class="c1">// 打开调试输出
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">setVerbose</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="02-g2o-类图">0.2 g2o 类图</h3>
<ul>
<li>
<p>先给出前面初始化的代码再看类图吧，直接看图一脸懵，参考<a href="https://www.cnblogs.com/gaoxiang12/p/5304272.html">高翔的博客</a>
<img src="https://img-blog.csdnimg.cn/20181225224642745.png" alt=""></p>
</li>
<li>
<p>上图中左侧的 <strong><code>SparseOptimizer</code></strong> 是第一步初始化的图模型，也是最终要维护的；</p>
</li>
<li>
<p>先看<strong>下半部分</strong>，对应前面的初始化代码，用于<strong>指定求解器和迭代算法</strong>，一个 <strong><code>SparseOptimizer</code></strong> 拥有一个 <strong><code>Optimization Algorithm</code></strong> ，其优化算法继承自 <strong><code>Gauss-Newton, Levernberg-Marquardt, Powell's dogleg</code></strong> 三者之一，不同的方法表现为最终的 H 矩阵构造不同；同时这个 <code>Optimization Algorithm</code> 拥有一个 <strong><code>Solver</code></strong> ，其包含两个部分：</p>
<ul>
<li>一个是 <strong><code>SparseBlockMatrix</code></strong> ，用于<strong>计算稀疏的雅克比和海森矩阵</strong>；</li>
<li>另一个是构造<strong>线性方程求解器</strong>，可以从 PCG, CSparse, Choldmod 三者选则，用于计算迭代过程中最关键的一步
$$
H \Delta x = -b
$$</li>
</ul>
</li>
<li>
<p>然后看<strong>上半部分</strong> <strong><code>SparseOptimizer</code></strong> 是一个 <strong><code>Optimizable Graph</code></strong> ，从而也是一个 <strong><code>Hyper Graph</code></strong>（超图）， 一个 <code>SparseOptimizer</code> 含有很多个<strong>顶点</strong>和很多个<strong>边</strong>；</p>
<ul>
<li>顶点继承自 <code>Base Vertex</code>，也就是 <code>OptimizableGraph::Vertex</code>；</li>
<li>边继承自 <code>OptimizableGraph::Edge</code>，又分为 <code>BaseUnaryEdge</code>（单边）, <code>BaseBinaryEdge</code>（双边）或 <code>BaseMultiEdge</code>（多边）；</li>
<li>这些 <code>Base Vertex</code> 和 <code>Base Edge</code> 都是抽象的基类，而<strong>实际用的顶点和边，都是它们的派生类</strong>；</li>
<li>用 <code>SparseOptimizer.addVertex()</code> 和 <code>SparseOptimizer.addEdge()</code> 向一个图中<strong>添加顶点和边</strong>，最后调用 <code>SparseOptimizer.optimize()</code> 完成优化。</li>
</ul>
</li>
<li>
<p>综上所述，在 g2o 中选择优化方法一共有三个步骤</p>
<ul>
<li><strong>步骤一：</strong> 选择线性方程 $H \Delta x = -b$ 的<!-- raw HTML omitted --><strong>线性方程求解器</strong><!-- raw HTML omitted -->，完全采用第三方的线性代数库，主要采用 Cholesky 分解和 PCG 迭代，具体可以选择的有
<ul>
<li>Cholmod，CSparse （以上两者为比较著名的线性代数库），</li>
<li>PCG （pre-conditioner is block Jacobi），</li>
<li>Dense（dense Cholesky decomposition），</li>
<li>或者 ORB-SLAM中使用的Eigen（sparse Cholesky decoposition from Eigen）</li>
</ul>
</li>
<li><strong>步骤二：</strong> 块求解器 BlockSolver 构造线性方程求解器所需要的<!-- raw HTML omitted -->**矩阵块（H 和 b）**<!-- raw HTML omitted -->，需要用到边的雅克比
$$
H = J^{T}WJ, \quad b=J^{T}W\delta 
$$
<ul>
<li>需要<strong>指定优化变量的维度</strong>，常见的有以下几种，其中 6 表示待优化变量的维度， 3 表示误差项的维度，可以设置为<strong>动态的 BlockSolverX</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// variable size solver
</span><span class="c1"></span><span class="k">using</span> <span class="n">BlockSolverX</span> <span class="o">=</span> <span class="n">BlockSolverPL</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// solver for BA/3D SLAM
</span><span class="c1"></span><span class="k">using</span> <span class="n">BlockSolver_6_3</span> <span class="o">=</span> <span class="n">BlockSolverPL</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// solver fo BA with scale
</span><span class="c1"></span><span class="k">using</span> <span class="n">BlockSolver_7_3</span> <span class="o">=</span> <span class="n">BlockSolverPL</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 2Dof landmarks 3Dof poses
</span><span class="c1"></span><span class="k">using</span> <span class="n">BlockSolver_3_2</span> <span class="o">=</span> <span class="n">BlockSolverPL</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><strong>步骤三：</strong> 选择<!-- raw HTML omitted --><strong>下降迭代策略</strong><!-- raw HTML omitted -->，从 GN, LM, Doglog 中选择。</li>
</ul>
</li>
<li>
<p>结合前面 0.1 节，总结一下 <strong>g2o 使用的流程</strong></p>
<ul>
<li><!-- raw HTML omitted --><strong>步骤一：</strong> 创建线性方程求解器，确定分解方法<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 每个误差项优化变量维度为3，误差值维度为1
</span><span class="c1"></span><span class="k">typedef</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BlockSolver</span><span class="o">&lt;</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BlockSolverTraits</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Block</span><span class="p">;</span>  
<span class="c1">// 创建一个线性求解器 LinearSolver，采用 dense cholesky 分解法
</span><span class="c1"></span><span class="n">Block</span><span class="o">::</span><span class="n">LinearSolverType</span><span class="o">*</span> <span class="n">linearSolver</span> 
    <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">LinearSolverDense</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">::</span><span class="n">PoseMatrixType</span><span class="o">&gt;</span><span class="p">();</span> 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>要求解的增量方程为 $H \Delta x = -b$，通常想到的方法就是直接求逆 $\Delta x = -H^{-1}*b$，对于较小维度的 H 矩阵可以直接求逆，但当 H 维度较大时采用下面的方法进行<strong>求逆</strong>：
<ul>
<li>LinearSolverCholmod：使用 sparse <strong>cholesky 分解法</strong>，继承自LinearSolverCCS；</li>
<li>LinearSolverCSparse：使用 CSparse 法，继承自LinearSolverCCS；</li>
<li>LinearSolverPCG ：使用preconditioned conjugate gradient 法，继承自 LinearSolver</li>
<li>LinearSolverDense ：使用 dense <strong>cholesky 分解法</strong>，继承自 LinearSolver</li>
<li>LinearSolverEigen： 依赖项只有 eigen，使用 eigen 中 sparse Cholesky  求解，因此编译好后可以方便的在其他地方使用，性能和 CSparse 差不多，继承自 LinearSolver；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><!-- raw HTML omitted --><strong>步骤二：</strong> 构造线性方程的矩阵块，并用上面定义的线性求解器初始化<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Block</span><span class="o">*</span> <span class="n">solver_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Block</span><span class="p">(</span> <span class="n">linearSolver</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>BlockSolver 内部包含 LinearSolver，用上面定义的线性求解器 LinearSolver 来初始化，前面已经给定了优化变量的维度；</li>
</ul>
</li>
<li><!-- raw HTML omitted --><strong>步骤三：</strong> 创建总求解器 solver，并从 GN, LM, DogLeg 中选一个，再用上述块求解器 BlockSolver 初始化<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmLevenberg</span><span class="o">*</span> <span class="n">solver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmLevenberg</span><span class="p">(</span> <span class="n">solver_ptr</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>优化算法
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmGaussNewton</span>
<span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmLevenberg</span> 
<span class="n">g2o</span><span class="o">::</span><span class="n">OptimizationAlgorithmDogleg</span> 
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><!-- raw HTML omitted --><strong>步骤四：</strong> 创建稀疏优化器（SparseOptimizer）<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">SparseOptimizer</span> <span class="n">optimizer</span><span class="p">;</span>     <span class="c1">// 图模型
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">setAlgorithm</span><span class="p">(</span> <span class="n">solver</span> <span class="p">);</span>   <span class="c1">// 用前面定义好的求解器作为求解方法：
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">setVerbose</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>       <span class="c1">// 打开调试输出
</span></code></pre></td></tr></table>
</div>
</div></li>
<li><!-- raw HTML omitted --><strong>步骤五：</strong> 定义图的顶点和边，并添加到 SparseOptimizer 优化器中<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 创建一个顶点
</span><span class="c1"></span><span class="n">CurveFittingVertex</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CurveFittingVertex</span><span class="p">();</span> 
<span class="c1">// 初始化顶点的值
</span><span class="c1"></span><span class="n">v</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
<span class="c1">// 设置顶点的编号
</span><span class="c1"></span><span class="n">v</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 向图中添加顶点
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span> <span class="n">v</span> <span class="p">);</span>
      
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>    <span class="c1">// 往图中增加边
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// 创建一条边
</span><span class="c1"></span>    <span class="n">CurveFittingEdge</span><span class="o">*</span> <span class="n">edge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CurveFittingEdge</span><span class="p">(</span> <span class="n">x_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
    <span class="c1">// 设置边的 id
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// 设置边连接的顶点
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="p">);</span>                
    <span class="c1">// 设置观测数值
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setMeasurement</span><span class="p">(</span> <span class="n">y_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>      
    <span class="c1">// 设置信息矩阵：协方差矩阵之逆
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setInformation</span><span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">()</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">w_sigma</span><span class="o">*</span><span class="n">w_sigma</span><span class="p">)</span> <span class="p">);</span> 
    <span class="c1">// 将边添加到图中
</span><span class="c1"></span>    <span class="n">optimizer</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span> <span class="n">edge</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><!-- raw HTML omitted --><strong>步骤六：</strong> 设置优化参数，开始执行优化<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">optimizer</span><span class="p">.</span><span class="n">initializeOptimization</span><span class="p">();</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// 迭代次数
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-g2o-的顶点vertex">1. g2o 的顶点（Vertex）</h2>
<h3 id="11-顶点的格式">1.1 顶点的格式</h3>
<p>  回到前面的类图上面的<strong>顶点</strong>部分的箭头，g2o 提供了一个比较通用的适合大多数情况的<strong>模板类 BaseVertex&lt;D, T&gt;（定义在 g2o/core/base_vertex.h 中）</strong>，其继承自 OptimizableGraph::Vertex（定义在 g2o/core/optimizable_graph.h 中），OptimizableGraph 又继承自 HyperGraph::Vertex（定义在 g2o/core/hyper_graph.h 中），后两者都比较底层，一般使用第一个。</p>
<ul>
<li>再来看看 <!-- raw HTML omitted --><strong>BaseVertex&lt;D, T&gt; 类的模板参数 D，T</strong><!-- raw HTML omitted -->
<ul>
<li><strong>D</strong> 是 int 类型，表示顶点 <strong>Vertex 的最小维度</strong>，比如 3D 空间中旋转是 3 维的，那么这里 D=3；
<ul>
<li>在源码注释中说 D 并非是顶点（更确切的说是状态变量）的维度，而是其在<strong>流形空间（manifold）的最小表示</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Dimension</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span> <span class="c1">///&lt; dimension of the estimate (minimal) in the manifold space
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><strong>T</strong> 是待估计 <strong>Vertex 的数据类型</strong>，比如用四元数表达三维旋转的话，T 就是 Quaternion 类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">T</span> <span class="n">EstimateType</span><span class="p">;</span>
<span class="n">EstimateType</span> <span class="n">_estimate</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>g2o 提供的<strong>常用的顶点类型</strong>，若没有的类型可参考自己定义
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="nl">VertexSE2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">SE2</span><span class="o">&gt;</span> <span class="c1">//2D pose Vertex, (x,y,theta)
</span><span class="c1"></span><span class="nl">VertexSE3</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">SE3Quat</span><span class="o">&gt;</span>
<span class="nl">VertexSE3</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">Isometry3</span><span class="o">&gt;</span>
<span class="nl">VertexPointXY</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&gt;</span>
<span class="nl">VertexPointXYZ</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vector3</span><span class="o">&gt;</span>
<span class="nl">VertexLine2D</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Line2D</span><span class="o">&gt;</span>
<span class="nl">VertexLine3D</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="n">Line3D</span><span class="o">&gt;</span>
<span class="nl">VertexSegment2D</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="n">Vector4</span><span class="o">&gt;</span>
<span class="nl">VertexCircle</span> <span class="p">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span>
<span class="nl">VertexPlane</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Plane3D</span><span class="o">&gt;</span>
<span class="nl">VertexCam</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">SBACam</span><span class="o">&gt;</span>
<span class="nl">VertexPosition3D</span> <span class="p">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span>
<span class="nl">VertexPositionVelocity3D</span> <span class="p">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">Vector6d</span><span class="o">&gt;</span>
<span class="nl">VertexOdomDifferentialParams</span><span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span> <span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vector3</span><span class="o">&gt;</span>
<span class="nl">VertexCameraBAL</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="o">&gt;</span>
<span class="nl">VertexSim3Expmap</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span> <span class="n">Sim3</span><span class="o">&gt;</span>
<span class="nl">VertexParams</span> <span class="p">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span>
<span class="nl">VertexSE3Expmap</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">SE3Quat</span><span class="o">&gt;</span>
<span class="nl">VertexBaseline</span> <span class="p">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>顶点<strong>主要的成员函数</strong>（位于 g2o/core/base_vertex.h 中）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 返回优化之后顶点的值.
</span><span class="c1"></span><span class="k">const</span> <span class="n">EstimateType</span><span class="o">&amp;</span> <span class="n">estimate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_estimate</span><span class="p">;}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="12-自定义顶点">1.2 自定义顶点</h3>
<ul>
<li>
<p>自定义一个顶点需要<!-- raw HTML omitted --><strong>重写以下函数</strong><!-- raw HTML omitted --></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setToOriginImpl</span><span class="p">();</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">oplusImpl</span><span class="p">(</span><span class="k">const</span> <span class="n">number_t</span><span class="o">*</span> <span class="n">update</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>read()</code> 和 <code>write()</code> 读盘、存盘函数</strong>，一般情况下不需要进行读/写操作的话，仅声明一下就可以了；</li>
<li><strong><code>setToOriginImpl()</code> 是顶点重置函数</strong>，设置被优化变量的<strong>初始值</strong>；</li>
<li><!-- raw HTML omitted --><strong><code>oplusImpl()</code> 是顶点更新函数</strong><!-- raw HTML omitted -->，主要用于优化过程中增量 $\Delta x$ 的计算；</li>
</ul>
</li>
<li>
<p><!-- raw HTML omitted -->自定义顶点类的<strong>格式</strong><!-- raw HTML omitted --></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">myVertex</span><span class="o">:</span> <span class="k">public</span> <span class="n">g2</span><span class="o">::</span><span class="n">BaseVertex</span><span class="o">&lt;</span><span class="n">Dim</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// 类成员变量如果是固定大小对象需要加上以下的宏定义
</span><span class="c1"></span>  <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

  <span class="c1">// 构造函数
</span><span class="c1"></span>  <span class="n">myVertex</span><span class="p">(){}</span>
      
  <span class="c1">// 读写函数
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>

  <span class="c1">// 重置函数
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setOriginImpl</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">_estimate</span> <span class="o">=</span> <span class="n">Type</span><span class="p">();</span>
  <span class="p">}</span>
    
  <span class="c1">// 更新函数
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">oplusImpl</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">update</span><span class="p">)</span> <span class="k">override</span>
  <span class="p">{</span>
      <span class="n">_estimate</span> <span class="o">+=</span> <span class="cm">/*update*/</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>举例一：</strong> 以 SLAM 十四讲中曲线拟合的<strong>曲线模型顶点</strong>为例</p>
<ul>
<li>定义顶点为 <code>CurveFittingVertex</code>，顶点维度为 3，类型为 <code>Eigen::Vector3d</code>；</li>
<li>初始值设为为 <code>0, 0, 0</code>；</li>
<li>更新函数中由于是<strong>向量直接加上更新量</strong> <code>_estimate += Eigen::Vector3d(update)</code>；</li>
<li>读写函数留空。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">CurveFittingVertex</span><span class="o">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
      
    <span class="c1">// 重置
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setToOriginImpl</span><span class="p">()</span> 
    <span class="p">{</span>
        <span class="n">_estimate</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
      
    <span class="c1">// 更新
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">oplusImpl</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">update</span> <span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">_estimate</span> <span class="o">+=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="n">update</span><span class="p">);</span>
    <span class="p">}</span>
      
    <span class="c1">// 存盘和读盘：留空
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>举例二：</strong> 以<strong>李代数表示的位姿作为顶点</strong>，位于 <code>g2o/types/sba/types_six_dof_expmap.h</code> 中</p>
<ul>
<li>定义顶点类为 <code>VertexSE3Expmap</code>，优化变量是 6 自由度的李代数；</li>
<li><strong>更新函数采用李代数的增量扰动更新</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * \brief SE3 Vertex parameterized internally with a transformation matrix
</span><span class="cm"> and externally with its exponential map
</span><span class="cm"> */</span>
<span class="k">class</span>  <span class="nc">VertexSE3Expmap</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">SE3Quat</span><span class="o">&gt;</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

  <span class="c1">// 构造函数.
</span><span class="c1"></span>  <span class="n">VertexSE3Expmap</span><span class="p">();</span>

  <span class="c1">// 1. 读盘.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
  <span class="c1">// 2. 写盘.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// 3. 顶点重置函数，设定被优化变量的原始值
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setToOriginImpl</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_estimate</span> <span class="o">=</span> <span class="n">SE3Quat</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 4. 顶点更新函数，增量更新
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">oplusImpl</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">update_</span><span class="p">)</span>  <span class="p">{</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Vector6d</span><span class="o">&gt;</span> <span class="n">update</span><span class="p">(</span><span class="n">update_</span><span class="p">);</span>
    <span class="n">setEstimate</span><span class="p">(</span><span class="n">SE3Quat</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="n">update</span><span class="p">)</span><span class="o">*</span><span class="n">estimate</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>举例三：</strong> 以三维向量表示的<strong>三维点</strong>作为顶点，位于 <code>g2o/types/types_sba.h</code> 中</p>
<ul>
<li>定义顶点类为 <code>VertexSBAPointXYZ</code>，优化变量是 3 维度的 Vector3d 向量；</li>
<li>重置与更新函数类似于举例一中的形式，直接相加。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">VertexSBAPointXYZ</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vector3d</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>    
    <span class="n">VertexSBAPointXYZ</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setToOriginImpl</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">_estimate</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">oplusImpl</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">update</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Vector3d</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">update</span><span class="p">);</span>
      <span class="n">_estimate</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="13-将顶点添加到图中">1.3 将顶点添加到图中</h3>
<ul>
<li><strong>步骤：</strong>
<ul>
<li>① 创建顶点</li>
<li>② 设置初始值</li>
<li>③ 设置节点编号</li>
<li>④ 添加到优化器中</li>
</ul>
</li>
<li><strong>举例一：曲线拟合</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CurveFittingVertex</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CurveFittingVertex</span><span class="p">();</span>
<span class="n">v</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
<span class="n">v</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span> <span class="n">v</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>举例二：三维坐标点</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Point3f</span> <span class="nl">p</span><span class="p">:</span><span class="n">points_3d</span> <span class="p">)</span>   <span class="c1">// landmarks
</span><span class="c1"></span><span class="p">{</span>
<span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="p">();</span>
<span class="n">point</span><span class="o">-&gt;</span><span class="n">setId</span> <span class="p">(</span> <span class="n">index</span><span class="o">++</span> <span class="p">);</span>
<span class="n">point</span><span class="o">-&gt;</span><span class="n">setEstimate</span> <span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="p">(</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">z</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">point</span><span class="o">-&gt;</span><span class="n">setMarginalized</span> <span class="p">(</span> <span class="nb">true</span> <span class="p">);</span> 
<span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span> <span class="p">(</span> <span class="n">point</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h2 id="2-g2o-中的边">2. g2o 中的边</h2>
<h3 id="21-边的格式">2.1 边的格式</h3>
<p>  还是回到前面的类图，关注右上角的边部分，我们一般使用的类是 <strong><code>BaseUnaryEdge，BaseBinaryEdge，BaseMultiEdge</code></strong> 分别表示<strong>一元边，两元边，多元边</strong>（位于 g2o/g2o/core/base_edge.h 中），类似于顶点，他们又继承自 <strong>OptimizableGraph::Edge</strong> （位于 g2o/g2o/core/optimizable_graph.h 中），<strong>hyper_graph::Edge</strong>（位于 g2o/g2o/core/hyper_graph.h 中）。     <br>
  <strong>一元边</strong>表示只连接一个顶点，<strong>二元边</strong>表示连接两个顶点，<strong>多元边</strong>表示连接 3 个或以上顶点。
<img src="https://i.loli.net/2019/03/05/5c7df32d30e9d.png" alt=""></p>
<ul>
<li>主要<!-- raw HTML omitted --><strong>参数有：D, E, VertexXi, VertexXj</strong><!-- raw HTML omitted -->
<ul>
<li>D 是 int 型，表示<strong>测量值的维度</strong>；</li>
<li>E 表示<strong>测量值的数据类型</strong>；</li>
<li>VertexXi，VertexXj 分别表示<strong>不同顶点的类型</strong>。</li>
<li>举例：用边表示<strong>三维点投影到图像平面的重投影误差</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BaseBinaryEdge</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="n">VertexSBAPointXYZ</span><span class="p">,</span> <span class="n">VertexSE3Expmap</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>首先顶点有两个是个，这是一个二元边；</li>
<li>误差（测量值）的<strong>维度</strong>为 2，也就是像素坐标 u,v 的差值；</li>
<li>误差（测量值）的<strong>数据类型</strong>为二维向量 Vector2D；</li>
<li>两个<strong>顶点也就是优化变量</strong>分别是三维点  VertexSBAPointXYZ 和李群表示的相机位姿VertexSE3Expmap。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="22-自定义边">2.2 自定义边</h3>
<ul>
<li>自定义边需要<!-- raw HTML omitted --><strong>重写以下成员函数</strong><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">computeError</span><span class="p">();</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">linearizeOplus</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>read()</code> 和 <code>write()</code> 读盘、存盘函数</strong>，一般情况下不需要进行读/写操作的话，仅声明一下就可以了；</li>
<li><strong><code>computeError()</code></strong>：重要，计算当前顶点<strong>计算出的测量值与真实的测量值之间的误差</strong>；</li>
<li><strong><code>linearizeOplus()</code></strong>：重要，在当前顶点的值下，该<strong>误差对优化变量的偏导数，也就是 Jacobian</strong>。</li>
</ul>
</li>
<li>除以上几个成员函数之外还有几个<strong>重要的成员变量和函数</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_measurement</span><span class="err">：存储观测值</span>
<span class="n">_error</span><span class="err">：存储</span><span class="n">computeError</span><span class="p">()</span> <span class="err">函数计算的误差</span>
<span class="n">_vertices</span><span class="p">[]</span><span class="err">：存储顶点信息，比如二元边的话，</span><span class="n">_vertices</span><span class="p">[]</span> <span class="err">的大小为</span><span class="mi">2</span><span class="err">，存储顺序和调用</span><span class="n">setVertex</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">vertex</span><span class="p">)</span> <span class="err">是设定的</span><span class="kt">int</span> <span class="err">有关（</span><span class="mi">0</span> <span class="err">或</span><span class="mi">1</span><span class="err">）</span>
<span class="n">setId</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">：来定义边的编号（决定了在</span><span class="n">H矩阵中的位置</span><span class="err">）</span>
<span class="n">setMeasurement</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="err">函数来定义观测值</span>
<span class="n">setVertex</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">vertex</span><span class="p">)</span> <span class="err">来定义顶点</span>
<span class="n">setInformation</span><span class="p">()</span> <span class="err">来定义协方差矩阵的逆</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>自定义边的格式</strong>：类似于定义顶点，但重点是 computeError()，linearizeOplus() 两个函数，也更复杂
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">myEdge</span><span class="o">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseBinaryEdge</span><span class="o">&lt;</span><span class="n">errorDim</span><span class="p">,</span> <span class="n">errorType</span><span class="p">,</span> <span class="n">Vertex1Type</span><span class="p">,</span> <span class="n">Vertex2Type</span><span class="o">&gt;</span>
<span class="p">{</span>
      <span class="k">public</span><span class="o">:</span>
      <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>      
      <span class="n">myEdge</span><span class="p">(){}</span>     
      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">)</span> <span class="p">{}</span>
      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>  
        
      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span> <span class="k">override</span>
      <span class="p">{</span>
          <span class="c1">// ...
</span><span class="c1"></span>          <span class="n">_error</span> <span class="o">=</span> <span class="n">_measurement</span> <span class="o">-</span> <span class="n">Something</span><span class="p">;</span>
      <span class="p">}</span>      
        
      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">linearizeOplus</span><span class="p">()</span> <span class="k">override</span>
      <span class="p">{</span>
          <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="o">=</span> <span class="n">something</span><span class="p">;</span>
          <span class="c1">// ...         
</span><span class="c1"></span>          <span class="cm">/*
</span><span class="cm">          _jocobianOplusXj(pos, pos) = something;
</span><span class="cm">          ...
</span><span class="cm">          */</span>
      <span class="p">}</span>      
      <span class="k">private</span><span class="o">:</span>
      <span class="c1">// data
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>举例一：一元边</strong>。来源<a href="https://github.com/gaoxiang12/slambook/blob/master/ch6/g2o_curve_fitting/main.cpp">十四讲中的曲线拟合</a>
<ul>
<li>定义误差边为 <code>CurveFittingEdge</code>，维度为 1，类型为 double，连接的顶点为 CurveFittingVertex；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">CurveFittingEdge</span><span class="o">:</span> <span class="k">public</span> <span class="n">g2o</span><span class="o">::</span><span class="n">BaseUnaryEdge</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="n">CurveFittingVertex</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
      
    <span class="n">CurveFittingEdge</span><span class="p">(</span> <span class="kt">double</span> <span class="n">x</span> <span class="p">)</span><span class="o">:</span> <span class="n">BaseUnaryEdge</span><span class="p">(),</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
      
    <span class="c1">// 计算曲线模型误差
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">CurveFittingVertex</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">CurveFittingVertex</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">abc</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">();</span>
        <span class="n">_error</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">_measurement</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span> <span class="n">abc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">_x</span><span class="o">*</span><span class="n">_x</span> <span class="o">+</span> <span class="n">abc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">_x</span> <span class="o">+</span> <span class="n">abc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
      
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">_x</span><span class="p">;</span>  <span class="c1">// x 值， y 值为 _measurement
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>举例二： 二元边</strong>。3D-2D点的PnP 问题，也就是最小化重投影误差问题，来源于 g2o/types/sba/types_six_dof_expmap.h
<ul>
<li>构造边为 <code>EdgeProjectXYZ2UV</code>，维度为 2，类型为 Vector2D，<strong>连接的两个顶点</strong>分别为<strong>三维点 VertexSBAPointXYZ</strong> 和<strong>李群表示的相机位姿 VertexSE3Expmap</strong>；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//继承了BaseBinaryEdge类，观测值是2维，类型Vector2D,顶点分别是三维点、李群位姿
</span><span class="c1"></span><span class="k">class</span> <span class="nc">G2O_TYPES_SBA_API</span> <span class="nl">EdgeProjectXYZ2UV</span> <span class="p">:</span> <span class="k">public</span>  <span class="n">BaseBinaryEdge</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="n">VertexSBAPointXYZ</span><span class="p">,</span> <span class="n">VertexSE3Expmap</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><span class="p">;</span>
      
    <span class="c1">//1. 构造函数初始化
</span><span class="c1"></span>    <span class="n">EdgeProjectXYZ2UV</span><span class="p">();</span>
      
    <span class="c1">//2. 计算误差
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span>  
    <span class="p">{</span>
      <span class="c1">// 李群相机位姿 顶点 v1
</span><span class="c1"></span>      <span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="c1">// 三维点 顶点 v2
</span><span class="c1"></span>      <span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="c1">//相机参数
</span><span class="c1"></span>      <span class="k">const</span> <span class="n">CameraParameters</span> <span class="o">*</span> <span class="n">cam</span>
        <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">CameraParameters</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
     <span class="c1">//误差计算，测量值减去估计值，也就是重投影误差obs-cam
</span><span class="c1"></span>     <span class="c1">//估计值计算方法是T*p,得到相机坐标系下坐标，然后在利用camera2pixel()函数得到像素坐标。
</span><span class="c1"></span>      <span class="n">Vector2D</span> <span class="n">obs</span><span class="p">(</span><span class="n">_measurement</span><span class="p">);</span>
      <span class="n">_error</span> <span class="o">=</span> <span class="n">obs</span><span class="o">-</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">cam_map</span><span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">()));</span>
    <span class="p">}</span>
      
    <span class="c1">//3. 线性增量函数，也就是雅克比矩阵J的计算方法
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">linearizeOplus</span><span class="p">();</span>
      
    <span class="c1">//4. 相机参数
</span><span class="c1"></span>    <span class="n">CameraParameters</span> <span class="o">*</span> <span class="n">_cam</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>关于<!-- raw HTML omitted --><strong>误差计算函数：误差 = 观测 - 投影</strong><!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_error</span> <span class="o">=</span> <span class="n">obs</span> <span class="o">-</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">cam_map</span><span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">()));</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>其中 obs 是观测值，当前帧中观察到的特征点的像素坐标；</li>
<li>v1 是相机位姿，v2 是地图点坐标，cam 是相机参数；</li>
<li><code>v1-&gt;estimate().map(v2-&gt;estimate())</code> 是<strong>利用相机位姿（外参）将地图点坐标从世界坐标系转换到相机坐标系</strong>；（.map 操作定义在 g2o/types/sim3/sim3.h 中）</li>
<li><code>cam-&gt;cam_map(v1-&gt;estimate().map(v2-&gt;estimate()))</code> 是<strong>利用相机内参将地图点从相机坐标系转换到图像坐标系</strong>。（cam_map 操作定义在 g2o/types/sba/types_six_dof_expmap.cpp 中）</li>
</ul>
</li>
<li>关于<!-- raw HTML omitted --><strong>雅克比矩阵</strong>的计算函数 <strong><code>linearizeOplus()</code></strong>：<strong>误差（观测相机方程）关于相机位姿和三维点的偏导数</strong><!-- raw HTML omitted -->
<img src="https://img-blog.csdnimg.cn/20190914172413878.png#pic_center" alt="">
<img src="https://img-blog.csdnimg.cn/2019091417243290.png#pic_center" alt="">
<ul>
<li>上式分别对应下面代码中的 <strong>_jacobianOplusXj</strong> 和 <strong>_jacobianOplusXi</strong>（代码位于 g2o/g2o/types/sba/types_six_dof_expmap.cpp 中）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="kt">void</span> <span class="n">EdgeProjectXYZ2UV</span><span class="o">::</span><span class="n">linearizeOplus</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">VertexSE3Expmap</span> <span class="o">*</span> <span class="n">vj</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSE3Expmap</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">SE3Quat</span> <span class="nf">T</span><span class="p">(</span><span class="n">vj</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">());</span>
  <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">vi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">Vector3D</span> <span class="n">xyz</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">();</span>
  <span class="n">Vector3D</span> <span class="n">xyz_trans</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">xyz</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">CameraParameters</span> <span class="o">*</span> <span class="n">cam</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">CameraParameters</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

  <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">ColMajor</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">z</span><span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>

  <span class="n">tmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>

  <span class="n">_jacobianOplusXi</span> <span class="o">=</span>  <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">T</span><span class="p">.</span><span class="n">rotation</span><span class="p">().</span><span class="n">toRotationMatrix</span><span class="p">();</span>

  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">z_2</span><span class="p">))</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>

  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">z_2</span><span class="p">)</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">focal_length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="23-将边添加到图中">2.3 将边添加到图中</h3>
<ul>
<li>
<p><strong>举例一：一元边。</strong> 以曲线拟合为例（slambook/ch6/g2o_curve_fitting/main.cpp）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 创建边
</span><span class="c1"></span>    <span class="n">CurveFittingEdge</span><span class="o">*</span> <span class="n">edge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CurveFittingEdge</span><span class="p">(</span> <span class="n">x_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
      
    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>                         <span class="c1">// 设置边的 id
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="p">);</span>                <span class="c1">// 设置连接的顶点
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setMeasurement</span><span class="p">(</span> <span class="n">y_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>      <span class="c1">// 观测数值
</span><span class="c1"></span>      
    <span class="c1">// 信息矩阵：协方差矩阵之逆
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setInformation</span><span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">()</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">w_sigma</span><span class="o">*</span><span class="n">w_sigma</span><span class="p">)</span> <span class="p">);</span> 
      
    <span class="c1">// 将边添加到图中
</span><span class="c1"></span>    <span class="n">optimizer</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span> <span class="n">edge</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>举例二：二元边。</strong> 位于 slambook/ch7/pose_estimation_3d2d.cpp 中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Point2f</span> <span class="nl">p</span><span class="p">:</span><span class="n">points_2d</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 创建边.
</span><span class="c1"></span>    <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeProjectXYZ2UV</span><span class="o">*</span> <span class="n">edge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeProjectXYZ2UV</span><span class="p">();</span>
    <span class="c1">// 设置边的 id
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setId</span> <span class="p">(</span> <span class="n">index</span> <span class="p">);</span>
    <span class="c1">// 指定连接的顶点
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setVertex</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span> <span class="p">(</span> <span class="n">optimizer</span><span class="p">.</span><span class="n">vertex</span> <span class="p">(</span> <span class="n">index</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setVertex</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pose</span> <span class="p">);</span>
      
    <span class="c1">// 设置观测值
</span><span class="c1"></span>    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setMeasurement</span> <span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span> <span class="p">(</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
      
    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setParameterId</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="p">);</span>
      
    <span class="n">edge</span><span class="o">-&gt;</span><span class="n">setInformation</span> <span class="p">(</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2d</span><span class="o">::</span><span class="n">Identity</span><span class="p">()</span> <span class="p">);</span>
      
    <span class="n">optimizer</span><span class="p">.</span><span class="n">addEdge</span> <span class="p">(</span> <span class="n">edge</span> <span class="p">);</span>
    <span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>注意在 <strong>setVertex() 中设置顶点的 id 和类型时要与边的类中定义的相对应</strong>，比如定义边时 v1 表示相机位姿，id 为 1，v2 表示三维点，id 为0
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">G2O_TYPES_SBA_API</span> <span class="n">EdgeProjectXYZ2UV</span> 
<span class="p">.....</span>
 <span class="c1">//李群相机位姿v1
</span><span class="c1"></span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="c1">// 顶点v2
</span><span class="c1"></span><span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-orb-slam2-中的顶点">3. ORB-SLAM2 中的顶点</h2>
<ul>
<li>前一篇文章笔记提到在 ORB-SLAM2 中<strong>顶点</strong>有三个，<strong>SE(3) 相机位姿</strong>、<strong>地图点坐标</strong>、<strong>闭环检测时的 sim(3) 相机位姿</strong>；
<ul>
<li>在<strong>每帧的位姿优化</strong> Optimizer::PoseOptimization() 函数中只将相机位姿作为顶点；</li>
<li>在 <strong>BA 优化</strong> 中将相机位姿和地图点两者作为顶点；</li>
<li>在<strong>闭环时</strong>将 sim(3) 相机位姿作为顶点。</li>
</ul>
</li>
</ul>
<h3 id="31-相机位姿顶点">3.1 相机位姿顶点</h3>
<ul>
<li>与前面<strong>自定义顶点的举例二</strong>中一样，即 g2o/types/types_six_dof_expmap.h 中 <strong>6 维李代数表示的 VertexSE3Expmap</strong>。</li>
</ul>
<h3 id="32-地图点坐标顶点">3.2 地图点坐标顶点</h3>
<ul>
<li>与前面<strong>自定义顶点的举例三</strong>中一样，即 g2o/types/types_sba.h 中<strong>三维向量表示的 VertexSBAPointXYZ</strong>。</li>
</ul>
<h3 id="33-闭环时的-sim3-相机位姿">3.3 闭环时的 sim3 相机位姿</h3>
<ul>
<li>与 6 维李代数表示的相机为了多了一个尺度因子
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 7 维 Sim3 表示的相机位姿.（用于闭环），增加了一个尺度 s.
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">VertexSim3Expmap</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseVertex</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span> <span class="n">Sim3</span><span class="o">&gt;</span>
  <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

    <span class="n">VertexSim3Expmap</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// 重置函数，尺度因子 s 设置为 1.
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setToOriginImpl</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">_estimate</span> <span class="o">=</span> <span class="n">Sim3</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 顶点更新函数.
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">oplusImpl</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">update_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Vector7d</span><span class="o">&gt;</span> <span class="n">update</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">update_</span><span class="p">));</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">_fix_scale</span><span class="p">)</span>
        <span class="n">update</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="n">Sim3</span> <span class="n">s</span><span class="p">(</span><span class="n">update</span><span class="p">);</span>
      <span class="n">setEstimate</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">estimate</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Vector2d</span> <span class="n">_principle_point1</span><span class="p">,</span> <span class="n">_principle_point2</span><span class="p">;</span>
    <span class="n">Vector2d</span> <span class="n">_focal_length1</span><span class="p">,</span> <span class="n">_focal_length2</span><span class="p">;</span>

    <span class="c1">// 地图点投影到闭环帧的坐标？
</span><span class="c1"></span>    <span class="n">Vector2d</span> <span class="nf">cam_map1</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector2d</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="n">Vector2d</span> <span class="n">res</span><span class="p">;</span>
      <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">_focal_length1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">_principle_point1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">_focal_length1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">_principle_point1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 地图点投影到当前帧的坐标？
</span><span class="c1"></span>    <span class="n">Vector2d</span> <span class="nf">cam_map2</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector2d</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
      <span class="n">Vector2d</span> <span class="n">res</span><span class="p">;</span>
      <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">_focal_length2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">_principle_point2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">_focal_length2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">_principle_point2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">_fix_scale</span><span class="p">;</span>


  <span class="k">protected</span><span class="o">:</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h2 id="4-orb-slam2-中的边">4. ORB-SLAM2 中的边</h2>
<h3 id="41-位姿优化时的重投影误差">4.1 位姿优化时的重投影误差</h3>
<ul>
<li>在 PoseOptimization() <strong>仅优化相机位姿</strong> 时，重投影误差是一个<strong>一元边</strong>，顶点（优化变量）为<strong>相机的位姿</strong>。对应 g2o/types/types_six_dof_expmap.h 中定义的边 <strong>EdgeSE3ProjectXYZOnlyPose</strong>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 一元边：重投影误差（仅用于优化相机位姿时）
</span><span class="c1"></span><span class="k">class</span>  <span class="nc">EdgeSE3ProjectXYZOnlyPose</span><span class="o">:</span> <span class="k">public</span>  <span class="n">BaseUnaryEdge</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Vector2d</span><span class="p">,</span> <span class="n">VertexSE3Expmap</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

  <span class="n">EdgeSE3ProjectXYZOnlyPose</span><span class="p">(){}</span>

  <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// 误差计算函数.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span>  
  <span class="p">{</span>
    <span class="c1">// 李代数表示的相机位姿 v1（顶点）.
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// 观测值：特征点当前帧中的坐标.
</span><span class="c1"></span>    <span class="n">Vector2d</span> <span class="n">obs</span><span class="p">(</span><span class="n">_measurement</span><span class="p">);</span>

    <span class="c1">// 重投影误差，.map() 是将地图点的世界坐标转换到相机坐标系，cam_project() 操作将其投影到当前帧.
</span><span class="c1"></span>    <span class="n">_error</span> <span class="o">=</span> <span class="n">obs</span><span class="o">-</span><span class="n">cam_project</span><span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">Xw</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// 检查地图点在相机坐标系中的深度是否为正.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">isDepthPositive</span><span class="p">()</span> 
  <span class="p">{</span>
    <span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">Xw</span><span class="p">))(</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 雅克比矩阵：重投影误差相对于相机位姿的一阶导.
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">linearizeOplus</span><span class="p">();</span>

  <span class="c1">// 投影到当前帧.
</span><span class="c1"></span>  <span class="n">Vector2d</span> <span class="nf">cam_project</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span> <span class="o">&amp;</span> <span class="n">trans_xyz</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">Vector3d</span> <span class="n">Xw</span><span class="p">;</span>  <span class="c1">// 地图点的世界坐标.
</span><span class="c1"></span>
  <span class="kt">double</span> <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">;</span>  <span class="c1">// 相机参数.
</span><span class="c1"></span><span class="p">};</span> <span class="c1">// 边：重投影误差（仅用于优化相机位姿时）.
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>其中 linearizeOplus() 函数<strong>构造雅克比矩阵</strong>，对应 <code>g2o/types/types_six_dof_expmap.cpp</code> 中的 <code>void EdgeSE3ProjectXYZOnlyPose::linearizeOplus()</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 优化相机位姿是重投影误差的雅克比矩阵（对相机位姿的偏导）
</span><span class="c1"></span><span class="kt">void</span> <span class="n">EdgeSE3ProjectXYZOnlyPose</span><span class="o">::</span><span class="n">linearizeOplus</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="c1">// 顶点：相机位姿.
</span><span class="c1"></span>  <span class="n">VertexSE3Expmap</span> <span class="o">*</span> <span class="n">vi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSE3Expmap</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="c1">// 地图点的相机坐标.
</span><span class="c1"></span>  <span class="n">Vector3d</span> <span class="n">xyz_trans</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">Xw</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">invz</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">xyz_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">invz_2</span> <span class="o">=</span> <span class="n">invz</span><span class="o">*</span><span class="n">invz</span><span class="p">;</span>

  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">invz_2</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">invz_2</span><span class="p">))</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="n">invz</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">invz</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">invz_2</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>

  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">invz_2</span><span class="p">)</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">invz_2</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">invz</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">invz</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="n">invz_2</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// 优化相机位姿是重投影误差的雅克比矩阵.
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="42-ba-优化时的重投影误差">4.2 BA 优化时的重投影误差</h3>
<ul>
<li>在 <strong>BA 优化时优化的量包括相机位姿和地图点坐标，重投影误差是一个二元边</strong>，连接的顶点为李代数表示的相机位姿和三维向量表示的地图点坐标。对应 g2o/types/types_six_dof_expmap.h 中定义的边 <strong>EdgeSE3ProjectXYZ</strong>，其定义格式与前面自定义边中举例二的二元边一样。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 边：重投影误差（BA优化时）
</span><span class="c1"></span><span class="k">class</span>  <span class="nc">EdgeSE3ProjectXYZ</span><span class="o">:</span> <span class="k">public</span>  <span class="n">BaseBinaryEdge</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Vector2d</span><span class="p">,</span> <span class="n">VertexSBAPointXYZ</span><span class="p">,</span> <span class="n">VertexSE3Expmap</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

  <span class="n">EdgeSE3ProjectXYZ</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// 误差计算函数
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span>  
  <span class="p">{</span>
    <span class="c1">// 顶点 v1：相机位姿，顶点的 id 为 1.
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="c1">// 顶点 v2：地图点，顶点的 id 为 0.
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="c1">// 观测值：特征点在当前帧中的像素坐标.
</span><span class="c1"></span>    <span class="n">Vector2d</span> <span class="n">obs</span><span class="p">(</span><span class="n">_measurement</span><span class="p">);</span>
    <span class="c1">// 计算误差：观测-重投影.
</span><span class="c1"></span>    <span class="n">_error</span> <span class="o">=</span> <span class="n">obs</span><span class="o">-</span><span class="n">cam_project</span><span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="c1">// 检查地图点在相机坐标系中深度是否为正.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">isDepthPositive</span><span class="p">()</span> 
  <span class="p">{</span>
    <span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSE3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">()))(</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 构造雅克比矩阵：重投影误差相对于相机坐标和地图点的一阶导.
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">linearizeOplus</span><span class="p">();</span>

  <span class="c1">// 投影到当前帧.
</span><span class="c1"></span>  <span class="n">Vector2d</span> <span class="nf">cam_project</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span> <span class="o">&amp;</span> <span class="n">trans_xyz</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// 边：重投影误差（BA优化时）.
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>其中 linearizeOplus() 函数用于<strong>构造雅克比矩阵，需要重投影误差对相机位姿和地图点求一阶偏导</strong>，对应 g2o/types/types_six_dof_expmap.cpp 中的 void EdgeSE3ProjectXYZ::linearizeOplus() 。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 重投影误差的雅克比矩阵（BA 优化时相对于相机位姿和地图点的一阶导）
</span><span class="c1"></span><span class="kt">void</span> <span class="n">EdgeSE3ProjectXYZ</span><span class="o">::</span><span class="n">linearizeOplus</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="n">VertexSE3Expmap</span> <span class="o">*</span> <span class="n">vj</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSE3Expmap</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">SE3Quat</span> <span class="nf">T</span><span class="p">(</span><span class="n">vj</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">());</span>
  <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">vi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">Vector3d</span> <span class="n">xyz</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">();</span>
  <span class="n">Vector3d</span> <span class="n">xyz_trans</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">xyz</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="n">xyz_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">;</span>

  <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">fx</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">z</span><span class="o">*</span><span class="n">fx</span><span class="p">;</span>

  <span class="n">tmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">fy</span><span class="p">;</span>
  <span class="n">tmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="o">*</span><span class="n">fy</span><span class="p">;</span>

  <span class="n">_jacobianOplusXi</span> <span class="o">=</span>  <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">T</span><span class="p">.</span><span class="n">rotation</span><span class="p">().</span><span class="n">toRotationMatrix</span><span class="p">();</span>

  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span>  <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">z_2</span><span class="p">))</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">fx</span><span class="p">;</span>

  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">z_2</span><span class="p">)</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">z</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
  <span class="n">_jacobianOplusXj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">z_2</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// 重投影误差的雅克比矩阵（BA 优化时相对于相机位姿和地图点的一阶导）
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="43-闭环检测时的重投影误差">4.3 闭环检测时的重投影误差</h3>
<ul>
<li>闭环检测时执行 <strong>sim3 优化</strong>，边是重投影误差，<strong>顶点是 sim3 表示的相机位姿和地图点坐标</strong>，对应 g2o/types/types_seven_dof_expmap.h 中定义的边投影到当前帧 <strong>EdgeSim3ProjectXYZ</strong> 和  投影到闭环帧 <strong>EdgeInverseSim3ProjectXYZ</strong>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 边：重投影误差（闭环检测时）顶点：地图点坐标，sim3 表示的相机位姿.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">EdgeSim3ProjectXYZ</span> <span class="o">:</span> <span class="k">public</span>  <span class="n">BaseBinaryEdge</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">Vector2d</span><span class="p">,</span>  <span class="n">VertexSBAPointXYZ</span><span class="p">,</span> <span class="n">VertexSim3Expmap</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

    <span class="n">EdgeSim3ProjectXYZ</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// 重投影误差计算.
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">const</span> <span class="n">VertexSim3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSim3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSBAPointXYZ</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

      <span class="n">Vector2d</span> <span class="n">obs</span><span class="p">(</span><span class="n">_measurement</span><span class="p">);</span>
      <span class="n">_error</span> <span class="o">=</span> <span class="n">obs</span><span class="o">-</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">cam_map1</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">())));</span>
    <span class="p">}</span>

    <span class="c1">// TODO 这里继承的 BaseBinaryEdge 雅克比矩阵构造函数？.
</span><span class="c1"></span>    <span class="c1">// virtual void linearizeOplus();
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="44-sim3-之间的相对误差">4.4 Sim3 之间的相对误差</h3>
<ul>
<li>OptimizeEssentialGraph 会在成功进行闭环检测后、全局 BA 优化前进行，<strong>边为 Sim3 之间的相对误差，顶点为 Sim3 表示的相机位姿</strong>。对应 g2o/types/types_seven_dof_expmap.h 中定义的边 <strong>EdgeSim3</strong>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BRIEF 边：Sim3 之间的相对误差，顶点：Sim3 表示的 pose。（OptimizeEssentialGraph 优化中）
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">EdgeSim3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseBinaryEdge</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span> <span class="n">Sim3</span><span class="p">,</span> <span class="n">VertexSim3Expmap</span><span class="p">,</span> <span class="n">VertexSim3Expmap</span><span class="o">&gt;</span>
  <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

    <span class="n">EdgeSim3</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// 误差计算.
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">computeError</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="k">const</span> <span class="n">VertexSim3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSim3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="k">const</span> <span class="n">VertexSim3Expmap</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">VertexSim3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

      <span class="n">Sim3</span> <span class="n">C</span><span class="p">(</span><span class="n">_measurement</span><span class="p">);</span>
      <span class="n">Sim3</span> <span class="n">error_</span><span class="o">=</span><span class="n">C</span><span class="o">*</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">()</span><span class="o">*</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">().</span><span class="n">inverse</span><span class="p">();</span>
      <span class="n">_error</span> <span class="o">=</span> <span class="n">error_</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">initialEstimatePossible</span><span class="p">(</span><span class="k">const</span> <span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">VertexSet</span><span class="o">&amp;</span> <span class="p">,</span> <span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">1.</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">initialEstimate</span><span class="p">(</span><span class="k">const</span> <span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">VertexSet</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">,</span> <span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*</span> <span class="cm">/*to*/</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">VertexSim3Expmap</span><span class="o">*</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSim3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">VertexSim3Expmap</span><span class="o">*</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VertexSim3Expmap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">from</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">v2</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">measurement</span><span class="p">()</span><span class="o">*</span><span class="n">v1</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">());</span>
      <span class="k">else</span>
        <span class="n">v1</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">measurement</span><span class="p">().</span><span class="n">inverse</span><span class="p">()</span><span class="o">*</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">estimate</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">};</span> <span class="c1">// 边：Sim3 之间的相对误差，顶点：Sim3 表示的 pose。（OptimizeEssentialGraph 优化中）
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h2 id="5-orb-slam2-中的优化函数">5. ORB-SLAM2 中的优化函数</h2>
<h3 id="51-位姿优化函数-poseoptimization">5.1 位姿优化函数 PoseOptimization()</h3>
<ul>
<li><strong>函数描述：</strong>
<ul>
<li>在 Tracking 线程中进行位姿优化的时候，每进行过一次 <strong>PnP 投影操作将地图点投影到当前平面上之后</strong>，都会进行一次PoseOptimization 位姿优化最小化重投影误差；</li>
<li>3D-2D <strong>最小化重投影误差</strong> e = (u,v) - project(Tcw*Pw)；</li>
<li><strong>只优化当前帧 pose，地图点固定</strong>；</li>
<li>用于 LocalTracking 中运动模型跟踪，参考帧跟踪，地图跟踪 TrackLocalMap，重定位。</li>
</ul>
</li>
<li><strong>顶点和边：</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mf">1.</span> <span class="nl">Vertex</span><span class="p">:</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">()</span><span class="err">，即当前帧的</span> <span class="n">Tcw</span>
<span class="mf">2.</span> <span class="nl">Edge</span><span class="p">:</span> <span class="err">重投影误差（一元边）</span>
 <span class="o">-</span> <span class="err">单目情况：</span><span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZOnlyPose</span><span class="p">()</span><span class="err">，</span><span class="n">BaseUnaryEdge</span>
     <span class="o">+</span> <span class="n">Vertex</span><span class="err">：待优化当前帧的</span><span class="n">Tcw</span>
     <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在当前帧中的二维位置</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
     <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
 <span class="o">-</span> <span class="err">双目情况：</span><span class="n">g2o</span><span class="o">::</span><span class="n">EdgeStereoSE3ProjectXYZOnlyPose</span><span class="p">()</span><span class="err">，</span><span class="n">BaseUnaryEdge</span>
     <span class="o">+</span> <span class="n">Vertex</span><span class="err">：待优化当前帧的</span><span class="n">Tcw</span>
     <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在当前帧中的二维位置</span><span class="p">(</span><span class="n">ul</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">ur</span><span class="p">)</span>
     <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>函数执行流程：</strong>
<ul>
<li><strong>步骤一：</strong> 构造 g2o <strong>优化器</strong></li>
<li><strong>步骤二：</strong> 向优化器中<strong>添加顶点</strong>-当前帧的位姿</li>
<li><strong>步骤三：</strong> 向优化器中<strong>添加边</strong>（以单目<strong>重投影误差</strong>为例）
<ul>
<li><strong>步骤 1：</strong> 实例化一个 EdgeSE3ProjectXYZOnlyPose 一元边
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZOnlyPose</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZOnlyPose</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤 2：</strong> 设置边连接的顶点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">e</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">optimizer</span><span class="p">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤 3：</strong> 添加边的观测值（2D）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">e</span><span class="o">-&gt;</span><span class="n">setMeasurement</span><span class="p">(</span><span class="n">obs</span><span class="p">);</span>     <span class="c1">// 观测：地图点在当前帧中的像素坐标.
</span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤 4：</strong> 设置边的信息矩阵
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">float</span> <span class="n">invSigma2</span> <span class="o">=</span> <span class="n">pFrame</span><span class="o">-&gt;</span><span class="n">mvInvLevelSigma2</span><span class="p">[</span><span class="n">kpUn</span><span class="p">.</span><span class="n">octave</span><span class="p">];</span>
<span class="c1">// note 设置权重（信息矩阵），与特征点金字塔有关，参考：https://www.zhihu.com/question/58762862
</span><span class="c1"></span><span class="n">e</span><span class="o">-&gt;</span><span class="n">setInformation</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2d</span><span class="o">::</span><span class="n">Identity</span><span class="p">()</span><span class="o">*</span><span class="n">invSigma2</span><span class="p">);</span>   <span class="c1">// 信息矩阵（权重）
</span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤 5：</strong> 设置核函数</li>
<li><strong>步骤 6：</strong> 获取地图点的世界坐标（3D）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">Xw</span> <span class="o">=</span> <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">GetWorldPos</span><span class="p">();</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">Xw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xw</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">Xw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xw</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">Xw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xw</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤 7：</strong> 将边添加到优化器中。</li>
</ul>
</li>
<li><strong>步骤四：开始优化，共优化 4 次</strong>，每次优化后将观测分为 outlier 和 inlier，outlier 不参与下次优化。
<ul>
<li>但由于每次优化后是对所有的观测进行outlier和inlier判别，因此之前被判别为outlier有可能变成inlier，反之亦然。</li>
<li>基于<strong>卡方检验</strong>计算异常值的阈值（假设测量有一个像素的偏差）。</li>
</ul>
</li>
<li><strong>步骤五：</strong> 优化结束，用优化之后的位姿更新当前帧的位姿。</li>
</ul>
</li>
</ul>
<h3 id="52-局部优化-localbundleadjustment">5.2 局部优化 LocalBundleAdjustment()</h3>
<ul>
<li><strong>函数描述</strong>
<ul>
<li>执行条件：在<strong>已经处理完队列中的最后一个关键帧之后</strong>，并且闭环检测线程没有请求停止局部建图线程，则开始<strong>对当前帧进行局部 BA 优化</strong>，或者当新的关键帧加入到 convisibility graph 时，<strong>在关键帧附近进行一次局部优化</strong>，如下图所示；
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->
<ul>
<li>Pos3 是新加入的关键帧，其初始估计位姿已经得到，此时，Pos2 是和 Pos3 相连的关键帧，X2 是 Pos3 看到的三维点，X1 是 Pos2 看到的三维点，这些都属于局部信息，<strong>共同参与Bundle Adjustment</strong>（圈内红色部分）；</li>
<li>同时，Pos1 也可以看到 X1，但它和 Pos3 没有直接的联系，属于 Pos3 关联的局部信息，<strong>参与 Bundle Adjustment，但取值保持不变</strong>（圈内灰色部分）；</li>
<li>Pos0 和 X0 <strong>不参与 Bundle Adjustment</strong>（圈外灰色部分）。</li>
<li>因此，参与优化的是上图中红色椭圆圈出的部分，其中红色代表取值会被优化，灰色代表取值保持不变。(u,v) 是 X 在 Pos 下的二维投影点，即 X 在 Pos 下的测量（measurement），<strong>优化的目标是让投影误差最小</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>顶点与边</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mf">1.</span> <span class="nl">Vertex</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">()</span><span class="err">，</span><span class="n">LocalKeyFrames</span><span class="err">，即当前关键帧一级与当前关键帧相连的关键帧的位姿</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">()</span><span class="err">，</span><span class="n">FixedCameras</span><span class="err">，即能观测到</span><span class="n">LocalMapPoints的关键帧</span><span class="err">（并且不属于</span><span class="n">LocalKeyFrames</span><span class="err">）的位姿，在优化中这些关键帧的位姿不变</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">LocalMapPoints</span><span class="err">，即</span><span class="n">LocalKeyFrames能观测到的所有MapPoints的位置</span>
<span class="mf">2.</span> <span class="nl">Edge</span><span class="p">:</span>
    <span class="o">-</span> <span class="err">单目</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">BaseBinaryEdge</span>
        <span class="o">+</span> <span class="n">Vertex</span><span class="err">：关键帧的</span><span class="n">Tcw</span><span class="err">，</span><span class="n">MapPoint的Pw</span>
        <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在关键帧中的二维位置</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
    <span class="o">-</span> <span class="err">双目</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeStereoSE3ProjectXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">BaseBinaryEdge</span>
        <span class="o">+</span> <span class="n">Vertex</span><span class="err">：关键帧的</span><span class="n">Tcw</span><span class="err">，</span><span class="n">MapPoint的Pw</span>
        <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在关键帧中的二维位置</span><span class="p">(</span><span class="n">ul</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">ur</span><span class="p">)</span>
        <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>函数执行流程</strong>
<ul>
<li><strong>步骤一：构造局部关键帧列表</strong>
<ul>
<li>步骤 1：将<strong>当前帧</strong>加入到列表中
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">list</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;</span> <span class="n">lLocalKeyFrames</span><span class="p">;</span>
<span class="n">lLocalKeyFrames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pKF</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 2：将<strong>与当前关键帧一级相连</strong>的关键帧加入到列表中
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyFrame</span><span class="o">*&gt;</span> <span class="n">vNeighKFs</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">GetVectorCovisibleKeyFrames</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><strong>步骤二：构造局部地图点列表</strong>。遍历前面的局部关键帧列表 lLocalKeyFrames，得到每个关键帧锁观测到的地图点，加入到局部地图点列表 lLocalMapPoints 中。</li>
<li><strong>步骤三：构造能被局部地图点观测到的但不属于局部关键帧列表的关键帧</strong> lFixedCameras 。这些关键帧参与局部 BA 但不改变其值。</li>
<li><strong>步骤四：构造 g2o 优化器</strong></li>
<li><strong>步骤五：向优化器中添加顶点 VertexSE3Expmap - 局部关键帧</strong>。遍历局部关键帧序列 lLocalKeyFrames，将其创建为顶点，添加到优化器中
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 实例化一个 VertexSE3Expmap 顶点的对象.
</span><span class="c1"></span><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span> <span class="o">*</span> <span class="n">vSE3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">();</span>
      
<span class="c1">// 设置顶点的关键帧位姿属性（SE3 形式）、ID 和固定的顶点.
</span><span class="c1"></span><span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">Converter</span><span class="o">::</span><span class="n">toSE3Quat</span><span class="p">(</span><span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">GetPose</span><span class="p">()));</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">);</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setFixed</span><span class="p">(</span><span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//第一帧位置固定
</span><span class="c1"></span>      
<span class="c1">// 将顶点添加到的优化器中.
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">vSE3</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤六：向优化器中添加顶点 VertexSE3Expmap - 不修改值的关键帧</strong>。遍历前面构造的 lFixedCameras，分别对齐创建为顶点，注意 setFixed(true) 不改变其值
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span> <span class="o">*</span> <span class="n">vSE3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">();</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">Converter</span><span class="o">::</span><span class="n">toSE3Quat</span><span class="p">(</span><span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">GetPose</span><span class="p">()));</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">);</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setFixed</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">vSE3</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤七：向优化器中添加顶点 VertexSBAPointXYZ - 地图点</strong>。遍历前面的局部地图点列表，依次创建顶点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 实例化一个 VertexSBAPointXYZ 顶点.
</span><span class="c1"></span><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">vPoint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="p">();</span>
<span class="c1">// 设置顶点的位置、ID，边缘化.
</span><span class="c1"></span><span class="n">vPoint</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">Converter</span><span class="o">::</span><span class="n">toVector3d</span><span class="p">(</span><span class="n">pMP</span><span class="o">-&gt;</span><span class="n">GetWorldPos</span><span class="p">()));</span>
<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="o">+</span><span class="n">maxKFid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">vPoint</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="n">vPoint</span><span class="o">-&gt;</span><span class="n">setMarginalized</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="c1">// 将顶点添加到优化器中.
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">vPoint</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤八：为每一对关联的地图点和关键帧创建边</strong>（与上一步构建地图点顶点一起创建，以单目为例）。
<ul>
<li>步骤 1：实例化一条二元边 EdgeSE3ProjectXYZ
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZ</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZ</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 2：为边添加关联的顶点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">e</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">optimizer</span><span class="p">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">id</span><span class="p">)));</span><span class="c1">// 地图点 ID.
</span><span class="c1"></span><span class="n">e</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">optimizer</span><span class="p">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">)));</span><span class="c1">// 关键帧 ID.
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 3：添加测量值
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">e</span><span class="o">-&gt;</span><span class="n">setMeasurement</span><span class="p">(</span><span class="n">obs</span><span class="p">);</span>     <span class="c1">// 测量：地图点在当前帧中的二维位置.
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 4：构造信息矩阵
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">invSigma2</span> <span class="o">=</span> <span class="n">pKFi</span><span class="o">-&gt;</span><span class="n">mvInvLevelSigma2</span><span class="p">[</span><span class="n">kpUn</span><span class="p">.</span><span class="n">octave</span><span class="p">];</span> <span class="c1">// 与特征点所在的尺度有关.
</span><span class="c1"></span><span class="n">e</span><span class="o">-&gt;</span><span class="n">setInformation</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2d</span><span class="o">::</span><span class="n">Identity</span><span class="p">()</span><span class="o">*</span><span class="n">invSigma2</span><span class="p">);</span>   <span class="c1">// 设置信息矩阵.
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 5：设置核函数</li>
<li>步骤 6：将边添加到优化器中</li>
</ul>
</li>
<li><strong>步骤九：开始执行优化，迭代 5 次</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">optimizer</span><span class="p">.</span><span class="n">initializeOptimization</span><span class="p">();</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>      <span class="c1">// 迭代 5 次.
</span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤十：检测 outlier</strong>，并设置下次不优化，同前面位姿优化时一样采用卡方检验计算阈值。</li>
<li><strong>步骤十一：排除误差较大的 outlier 后再次优化</strong>，迭代 10 次
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">optimizer</span><span class="p">.</span><span class="n">initializeOptimization</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤十二：在优化后重新计算误差，剔除连接误差比较大的关键帧和地图点</strong>。</li>
<li><strong>步骤十三：优化后更新关键帧位姿以及地图点坐标、平均观测方向等属性</strong>。</li>
</ul>
</li>
</ul>
<h3 id="53-全局优化-globalbundleadjustemnt">5.3 全局优化 GlobalBundleAdjustemnt()</h3>
<ul>
<li><strong>函数描述</strong>
<ul>
<li>全局 BA 优化在<strong>单目初始化和闭环矫正时执行</strong>。在全局优化中，<strong>所有的关键帧（除了第一帧）和三维点都参与优化</strong>，如下图所示：</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li><strong>顶点与边</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mi">3</span><span class="n">D</span><span class="o">-</span><span class="mi">2</span><span class="n">D</span> <span class="err">最小化重投影误差</span> <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">project</span><span class="p">(</span><span class="n">Tcw</span><span class="o">*</span><span class="n">Pw</span><span class="p">)</span>
<span class="mf">1.</span> <span class="nl">Vertex</span><span class="p">:</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">()</span><span class="err">，即当前帧的</span><span class="n">Tcw</span>
           <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">MapPoint</span> <span class="err">的</span> <span class="n">mWorldPos</span>
<span class="mf">2.</span> <span class="nl">Edge</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">BaseBinaryEdge</span>
        <span class="o">+</span> <span class="n">Vertex</span><span class="err">：待优化当前帧的</span><span class="n">Tcw</span>
        <span class="o">+</span> <span class="n">Vertex</span><span class="err">：待优化</span><span class="n">MapPoint的mWorldPos</span>
        <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在当前帧中的二维位置</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>函数执行流程</strong>
<ul>
<li><strong>步骤一：构造 g2o 优化器</strong>。</li>
<li><strong>步骤二：向优化器中添加顶点 VertexSE3Expmap - 关键帧的位姿。</strong> 遍历系统关键帧列表中的<strong>所有关键帧</strong>，依次添加顶点。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span> <span class="o">*</span> <span class="n">vSE3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSE3Expmap</span><span class="p">();</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">Converter</span><span class="o">::</span><span class="n">toSE3Quat</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">GetPose</span><span class="p">()));</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">);</span>
<span class="n">vSE3</span><span class="o">-&gt;</span><span class="n">setFixed</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 固定第一帧的位姿，其它帧可修正位姿
</span><span class="c1"></span><span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">vSE3</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤三：向优化器中添加顶点 VertexSBAPointXYZ - 地图点坐标</strong>。遍历所有关键帧观察到的地图点，依次添加为顶点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="o">*</span> <span class="n">vPoint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="p">();</span>
<span class="n">vPoint</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">Converter</span><span class="o">::</span><span class="n">toVector3d</span><span class="p">(</span><span class="n">pMP</span><span class="o">-&gt;</span><span class="n">GetWorldPos</span><span class="p">()));</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">pMP</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="o">+</span><span class="n">maxKFid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="n">vPoint</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="n">vPoint</span><span class="o">-&gt;</span><span class="n">setMarginalized</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">vPoint</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤四：向优化器中添加边 EdgeSE3ProjectXYZ - 重投影误差</strong>。
<ul>
<li>步骤 1：实例化一条边
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZ</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSE3ProjectXYZ</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 2：添加顶点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">e</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">optimizer</span><span class="p">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">id</span><span class="p">)));</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">setVertex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">g2o</span><span class="o">::</span><span class="n">OptimizableGraph</span><span class="o">::</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">optimizer</span><span class="p">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mnId</span><span class="p">)));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 3：添加测量值
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">obs</span><span class="p">;</span>
<span class="n">obs</span> <span class="o">&lt;&lt;</span> <span class="n">kpUn</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">kpUn</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">setMeasurement</span><span class="p">(</span><span class="n">obs</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 4：设置信息矩阵
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">invSigma2</span> <span class="o">=</span> <span class="n">pKF</span><span class="o">-&gt;</span><span class="n">mvInvLevelSigma2</span><span class="p">[</span><span class="n">kpUn</span><span class="p">.</span><span class="n">octave</span><span class="p">];</span>
<span class="n">e</span><span class="o">-&gt;</span><span class="n">setInformation</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2d</span><span class="o">::</span><span class="n">Identity</span><span class="p">()</span><span class="o">*</span><span class="n">invSigma2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>步骤 5：设置核函数</li>
<li>步骤 6：添加到优化器中</li>
</ul>
</li>
<li><strong>步骤五：开始优化，迭代 20 次</strong>。</li>
<li><strong>步骤六：更新优化结果</strong>（关键帧位姿、地图点坐标）。</li>
</ul>
</li>
</ul>
<h3 id="54-闭环处的-sim3-优化-optimizesim3">5.4 闭环处的 Sim3 优化 OptimizeSim3()</h3>
<ul>
<li><strong>函数描述</strong>
<ul>
<li>
<blockquote>
<p>在用 RANSAC 求解过 Sim3，以及通过 Sim3 匹配更多的地图点后，<strong>对当前关键帧，闭环关键帧，以及匹配的地图点进行优化</strong>，获得更准确的 Sim3 变换，再进行下一步的闭环调整；</p>
</blockquote>
</li>
<li>当检测到闭环时，<strong>闭环连接的两个关键帧的位姿需要通过 Sim3 优化（以使得其尺度一致）</strong>，在函数 <code>Optimizer::OptimizeSim3()</code> 中实现，优化求解<strong>两帧之间的相似变换矩阵</strong>，使得二维对应点的<strong>投影误差最小</strong>；</li>
<li>如下图所示，Pos6 和 Pos2 为一个可能的闭环，则通过 $(u_{4,2},v_{4,2})$ 和 $(u_{4,6},v_{4,6})$ 之间的投影误差来优化 $S_{6,2}$。</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li><strong>顶点与边</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mf">1.</span> <span class="nl">Vertex</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSim3Expmap</span><span class="p">()</span><span class="err">，两个关键帧的位姿</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSBAPointXYZ</span><span class="p">()</span><span class="err">，两个关键帧共有的</span> <span class="n">MapPoints</span>
<span class="mf">2.</span> <span class="nl">Edge</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSim3ProjectXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">BaseBinaryEdge</span><span class="err">，投影到当前帧</span>
         <span class="o">+</span> <span class="n">Vertex</span><span class="err">：关键帧的</span><span class="n">Sim3</span><span class="err">，</span><span class="n">MapPoint的Pw</span>
         <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在关键帧中的二维位置</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
         <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeInverseSim3ProjectXYZ</span><span class="p">()</span><span class="err">，</span><span class="n">BaseBinaryEdge</span><span class="err">，投影到闭环帧</span>
         <span class="o">+</span> <span class="n">Vertex</span><span class="err">：关键帧的</span><span class="n">Sim3</span><span class="err">，</span><span class="n">MapPoint的Pw</span>
         <span class="o">+</span> <span class="n">measurement</span><span class="err">：</span><span class="n">MapPoint在关键帧中的二维位置</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
         <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="n">invSigma2</span><span class="p">(</span><span class="err">与特征点所在的尺度有关</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>函数执行流程</strong>
<ul>
<li><strong>步骤一：</strong> 初始化 g2o 优化器；</li>
<li><strong>步骤二： 添加顶点 VertexSim3Expmap - sim3 位姿</strong>，顶点的值为两个关键帧之间的 sim3 变换；
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">g2o</span><span class="o">::</span><span class="n">VertexSim3Expmap</span> <span class="o">*</span> <span class="n">vSim3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSim3Expmap</span><span class="p">();</span>    
<span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_fix_scale</span><span class="o">=</span><span class="n">bFixScale</span><span class="p">;</span>
<span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">setEstimate</span><span class="p">(</span><span class="n">g2oS12</span><span class="p">);</span>     <span class="c1">// 两个关键帧间的Sim3变换
</span><span class="c1"></span><span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">setId</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">setFixed</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="c1">// 优化Sim3顶点
</span><span class="c1"></span><span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_principle_point1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 光心横坐标cx
</span><span class="c1"></span><span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_principle_point1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">K1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 光心纵坐标cy
</span><span class="c1"></span><span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_focal_length1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 焦距 fx
</span><span class="c1"></span><span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_focal_length1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">K1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 焦距 fy
</span><span class="c1"></span><span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_principle_point2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_principle_point2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">K2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_focal_length2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vSim3</span><span class="o">-&gt;</span><span class="n">_focal_length2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">K2</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">vSim3</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li><strong>步骤三： 添加顶点 VertexSBAPointXYZ - 两帧的共视地图点</strong>，顶点的值为地图点的相机坐标；</li>
<li><strong>步骤四：添加边 - 顶点投影到当前帧的重投影误差 EdgeSim3ProjectXYZ 和投影到闭环帧的重投影误差 EdgeInverseSim3ProjectXYZ</strong>；</li>
<li><strong>步骤五：</strong> 开始优化，迭代 5 次；</li>
<li><strong>步骤六：</strong> 卡方检验剔除误差较大的边；</li>
<li><strong>步骤七：</strong> 再次优化剩余的边，迭代 5 或者 10 次；</li>
<li><strong>步骤八：</strong> 优化结束，返回两帧之间的 sim3 变换。</li>
</ul>
</li>
</ul>
<h3 id="55-闭环后的-sim3-位姿优化-optimizeessentialgraph">5.5 闭环后的 Sim3 位姿优化 OptimizeEssentialGraph()</h3>
<ul>
<li>
<p><strong>函数描述</strong></p>
<ul>
<li>单目 SLAM 一般都会发生<strong>尺度（scale）漂移</strong>，因此 Sim3 上的优化是必要的，相对于SE3，<strong>Sim3 的自由度要多一个，而且优化的目标是矫正尺度因子，因此优化并没有加入更多的变量（如三维点）</strong>；</li>
<li>在<strong>检测到闭环时在 sim3 上对所有的位姿进行一次优化</strong>，在函数 <code>Optimizer::OptimizeEssentialGraph()</code> 中执行，EssentialGraph 包括<strong>所有的关键帧顶点</strong>，但是优化边大大减少，包括 spanning tree（生成树），共视权重θ&gt;100 的边，以及闭环连接边。用于<strong>闭环检测 Sim3 调整后优化</strong>。</li>
<li>定义 <strong>sim3 上的残差</strong>为：
$$
e_{i,j}=log_{Sim3}(S_{ij}S_{jw}S_{iw}^{-1})
$$</li>
<li>其中 $S_{iw}$ 的初值是尺度为 1 的 pos i 相对于世界坐标系的变换矩阵，$S_{jw}$ 同理；</li>
<li>$S_{ij}$ 表示 pos i 和 pos j 之间的相对位姿矩阵（sim3 优化之前），表示 $S_{iw}$ 和 $S_{jw}$ 之间的测量；</li>
<li>此处相当于<strong>认为局部的相对位姿是准确的，而全局位姿有累计误差</strong>，是不准确的</li>
</ul>
<!-- raw HTML omitted -->
</li>
<li>
<p><strong>顶点与边</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mf">1.</span> <span class="nl">Vertex</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">VertexSim3Expmap</span><span class="err">，</span><span class="n">Essential</span> <span class="n">graph中关键帧的位姿</span>
<span class="mf">2.</span> <span class="nl">Edge</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">g2o</span><span class="o">::</span><span class="n">EdgeSim3</span><span class="p">()</span><span class="err">，</span><span class="n">BaseBinaryEdge</span>
        <span class="o">+</span> <span class="n">Vertex</span><span class="err">：关键帧的</span><span class="n">Tcw</span><span class="err">，</span><span class="n">MapPoint的Pw</span>
        <span class="o">+</span> <span class="n">measurement</span><span class="err">：经过</span><span class="n">CorrectLoop函数步骤2</span><span class="err">，</span><span class="n">Sim3传播校正后的位姿</span>
        <span class="o">+</span> <span class="nl">InfoMatrix</span><span class="p">:</span> <span class="err">单位矩阵</span>   
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>函数执行流程</strong></p>
<ul>
<li><strong>步骤一：</strong> 初始化 g2o 优化器；</li>
<li><strong>步骤二：</strong> 添加顶点 VertexSim3Expmap - 地图中所有的关键帧；</li>
<li><strong>步骤三：</strong> 添加边
<ul>
<li>闭环时因为 MapPoints 调整而出现的新关键帧之间的 sim3 变换误差</li>
<li>当前帧与闭环匹配成功的帧之间的误差</li>
</ul>
</li>
<li><strong>步骤四：</strong> 开始优化，迭代 20 次；</li>
<li><strong>步骤五：</strong> 优化结束更新位姿 Sim3:[sR t;0 1] -&gt; SE3:[R t/s;0 1]；</li>
<li><strong>步骤六：</strong> MapPoints 根据参考帧优化前后的相对关系调整自己的位置（地图点坐标不是直接从优化器中更新的）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="r-参考资料">R. 参考资料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;mid=2247486858&amp;idx=1&amp;sn=ce458d5eb6b1ad11b065d71899e31a04&amp;chksm=97d7e81da0a0610b1e3e12415b6de1501329920c3074ab5b48e759edbb33d264a73f1a9f9faf&amp;scene=21#wechat_redirect">从零开始一起学习SLAM | 理解图优化，一步步带你看懂g2o代码</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&amp;mid=2247486992&amp;idx=1&amp;sn=ecb7c3ef9bd968e51914c2f5b767428d&amp;chksm=97d7eb87a0a062912a9db9fb16a08129f373791fd3918952342d5db46c0bc4880326a7933671&amp;scene=21#wechat_redirect">从零开始一起学习SLAM | 掌握g2o顶点编程套路</a></li>
<li><a href="https://www.cnblogs.com/CV-life/archive/2019/03/13/10525579.html">从零开始一起学习SLAM | 掌握g2o边的代码套路</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37843131">g2o：非线性优化与图论的结合</a></li>
<li><a href="https://www.cnblogs.com/gaoxiang12/p/5244828.html">深入理解图优化与g2o：图优化篇</a></li>
</ul>
<hr>
<h2 id="todo">TODO</h2>
<ul>
<li>5.4，5.5 这两个闭环时的优化函数没太理解，后面专门做一个关于闭环的总结把这两个函数带上。</li>
</ul>
<hr>
<blockquote>
<p>2019.07.05     <br>
<a href="mailto:wuyanminmax@gmail.com">wuyanminmax@gmail.com</a></p>
</blockquote>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/2019-07-12-nonparametric-statistics-and-clustering/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"> 📜 论文阅读 | 在非参数和聚类的 SLAM 中使用类别物体进行定位</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019-07-03-orb-slam2-optimization1/">
            <span class="next-text nav-default"> 😀 ORB-SLAM2 代码解读（三）：优化 1（概述）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="wuyanminmax@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/wuxiaolang" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/wuyanmin2018" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://wym.netlify.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  
  

  
  <div class="busuanzi-footer">
    
      
    
  </div>

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">wu</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: {equationNumbers: {autoNumber: "AMS"}},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-160646347-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?352520a6e7c1df580f6de1f879049608";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
